INSERT INTO public.security_controls (id, type, description) VALUES (1, 'AUTHENTICATION', 'Authentication is the process of verifying the identity of a user, system, or entity before granting access to a resource or system. It ensures that the person or system trying to access something is who they claim to be. This is typically done using credentials like passwords, biometrics, security tokens, or multi-factor authentication methods. Authentication is a critical component of security, as it prevents unauthorized access and protects sensitive data and systems.') ON CONFLICT (id) DO NOTHING;

INSERT INTO public.security_patterns (id, name, description, properties, security_control) VALUES (2, 'Passkey-based Authentication', '{"intent": "Enable secure, passwordless user authentication by leveraging public-key cryptography to verify identity, reducing the risks associated with password management, such as phishing, password reuse, and credential theft.", "problem": "How can a system authenticate users without relying on passwords, while providing resistance to phishing and credential theft, and improving user experience by eliminating the need for password management?", "solution": "Passkey-based authentication uses public-key cryptography. A unique pair of keys is generated for each user: the private key is securely stored on the user''s device, and the public key is stored on the server. When logging in, the user authenticates via a biometric input (e.g., fingerprint or facial recognition) or a device PIN. The private key is used to sign a challenge provided by the server, and the server verifies the response using the public key. The private key never leaves the user''s device, making it resistant to phishing attacks and credential theft.", "consequences": {"negative": [{"factor": "Device Dependency", "reason": "Users must have access to the device containing the private key, which introduces challenges if the device is lost or stolen"}, {"factor": "Recovery Complexity", "reason": "Recovering access if a device is lost or compromised can be more complex than resetting a password."}, {"factor": "Implementation Complexity", "reason": "Requires infrastructure to support public-key cryptography and secure storage of keys on devices."}, {"factor": "Device Compatibility", "reason": "Not all devices, especially older ones, may support the required cryptographic operations and secure key storage."}], "positive": [{"factor": "Strong Security", "reason": "Resistant to phishing, credential theft, and replay attacks because the private key never leaves the user''s device and is used for challenge-response authentication."}, {"factor": "Passwordless Experience", "reason": "Improves usability by eliminating password management, reducing the cognitive load on users."}, {"factor": "Device-Agnostic", "reason": "Passkeys are generally tied to user devices but can be transferred securely between devices if necessary."}, {"factor": "Phishing Resistance", "reason": "Prevents attackers from impersonating users because they cannot extract the private key from the device."}]}, "participants": {"human": [{"name": "User", "description": "The individual who owns the device that securely stores the private key and provides a biometric or PIN for authentication."}], "nonHuman": [{"name": "Authentication System", "description": "Generates the challenge and verifies the signed response using the public key."}, {"name": "Device", "description": "Stores the private key securely and performs cryptographic operations for authentication."}, {"name": "Certificate Authority", "optional": true, "description": "In some implementations, it may issue certificates that bind the public key to the user''s identity."}]}}', '{"cost": {"score": 3, "rationale": "Moderate cost due to the need for secure device storage and cryptographic infrastructure. The upfront costs are higher, but operational costs are lower in the long term."}, "usability": {"score": 4, "rationale": "More user-friendly than passwords, as it eliminates the need for password management and relies on devices for secure authentication. Some initial setup and device management are required."}, "compliance": {"score": 5, "rationale": "Passkey-based authentication easily meets modern compliance standards, such as GDPR, PCI DSS, and HIPAA, due to strong cryptographic protections."}, "performance": {"score": 4, "rationale": "Cryptographic operations involved in passkey-based authentication can introduce minor latency, but in most cases, performance remains high due to modern hardware optimizations."}, "scalability": {"score": 4, "rationale": "Passkey-based authentication scales well since cryptographic keys can be managed on the client side, though key distribution and management still require infrastructure."}, "auditability": {"score": 4, "rationale": "Strong auditability through logs of cryptographic operations, though managing audit logs for cryptographic events can be complex."}, "availability": {"score": 5, "rationale": "High availability as passkeys are stored locally on user devices, allowing for offline authentication in some cases."}, "confidentiality": {"score": 5, "rationale": "Confidentiality is very strong as the private key never leaves the user’s device, significantly reducing the risk of key exposure."}, "mfa_suitability": {"score": 5, "rationale": "Cryptographically strong factor based on something you have, seamlessly fits into MFA."}, "device_dependency": {"score": 5, "rationale": "High device dependency. Passkey-based authentication relies on the user''s device to store cryptographic keys (e.g., a smartphone or laptop). If the user loses the device, re-enrollment is necessary."}, "security_strength": {"score": 5, "rationale": "Passkey-based authentication provides extremely strong security due to the use of public-key cryptography. The private key never leaves the user’s device, making it highly resistant to phishing, brute-force, and man-in-the-middle attacks."}, "recovery_complexity": {"score": 2, "rationale": "If the user loses the device storing the private key, recovering access can be complex. Users must often enroll a new device, which can involve additional verification steps. Some systems offer backup keys, but recovery can still be more difficult than passwords."}, "maintenance_complexity": {"score": 3, "rationale": "Moderate maintenance complexity. Managing secure key storage and handling device migrations or key recovery adds some operational overhead."}, "resistance_to_phishing": {"score": 5, "rationale": "Extremely resistant to phishing as the private key is never transmitted or exposed, even if a phishing attempt succeeds."}, "third_party_dependency": {"score": 1, "rationale": "Typically no third-party dependency. Cryptographic keys are generated and managed by the system, with no reliance on third-party identity providers."}, "authentication_strength": {"score": 5, "rationale": "Strong authentication is provided by cryptographic key pairs, ensuring only users with the private key can authenticate."}, "implementation_complexity": {"score": 4, "rationale": "Higher complexity due to the need for cryptographic infrastructure, key management, and secure device storage, though modern libraries and tools ease some of the burdens."}, "infrastructure_dependency": {"score": 4, "rationale": "Requires robust cryptographic infrastructure for managing key pairs, signing challenges, and verifying responses. Complex key management is needed, though no external services are required."}}', 1) ON CONFLICT (id) DO NOTHING;
INSERT INTO public.security_patterns (id, name, description, properties, security_control) VALUES (9, 'Passphrase Authentication', '{"intent": "Enable secure user authentication by allowing users to create complex, memorable phrases as passwords, enhancing security by increasing password length and entropy while still being user-friendly.", "problem": "How can a system authenticate users securely with something memorable yet difficult to guess, avoiding the common weaknesses of short, simple passwords?", "solution": "Passphrase Authentication allows users to create long, complex strings of words or phrases instead of short passwords. The system hashes and securely stores the passphrase, just as it would a traditional password. Because passphrases are generally longer, they provide increased entropy, making them harder for attackers to guess or brute-force. During authentication, the user inputs their passphrase, which is hashed and compared with the stored hash for verification. Passphrases offer an accessible way to increase password strength without requiring difficult-to-remember character combinations.", "consequences": {"negative": [{"factor": "Storage Space", "reason": "Longer passphrases may require additional storage space compared to shorter passwords."}, {"factor": "Vulnerability to Common Phrases", "reason": "If users choose predictable phrases or common sayings, passphrases may still be susceptible to dictionary attacks."}, {"factor": "Typing Complexity", "reason": "Typing long passphrases on mobile devices or in secure environments can be inconvenient and time-consuming."}], "positive": [{"factor": "Enhanced Security", "reason": "Longer length and complexity make passphrases harder to guess and more resilient to brute-force attacks than short passwords."}, {"factor": "User-Friendly", "reason": "Easier for users to remember, as passphrases can consist of meaningful words or phrases."}, {"factor": "Device-Agnostic", "reason": "Compatible across various devices without needing special hardware or software."}]}, "participants": {"human": [{"name": "User", "description": "The individual who creates a passphrase and enters it during login for authentication."}], "non-human": [{"name": "Authentication System", "description": "Hashes the passphrase for secure storage and verifies it during authentication."}, {"name": "Passphrase Storage", "description": "Stores the hashed passphrase securely."}, {"name": "Hash Function", "description": "A cryptographic function that converts the passphrase into an irreversible hash."}]}}', '{"cost": {"score": 4.5, "rationale": "Passphrases are cost-effective because they rely on the same basic infrastructure as simple passwords but with longer input requirements. The only additional cost comes from the potential for slightly increased storage needs for the longer passphrases. However, passphrase implementation remains relatively simple and inexpensive."}, "usability": {"score": 2, "rationale": "Passphrases, while more secure, are more difficult for users to input and remember due to their length and complexity. Typing out long passphrases can be cumbersome and prone to errors, which lowers usability, particularly in systems where users are required to authenticate frequently."}, "compliance": {"score": 4, "rationale": "Passphrases meet compliance standards that require strong, complex credentials. Compliance frameworks such as PCI-DSS and ISO 27001 emphasize the need for strong password policies, and passphrases—due to their length and complexity—align well with these guidelines. As long as strong hashing mechanisms are applied, passphrases meet the requirements for secure credential management."}, "performance": {"score": 4, "rationale": "Passphrases generally maintain good performance, as they are treated similarly to passwords, but the longer input may slightly increase the time needed for the user to log in. Additionally, longer passphrases require more computational power to hash or store, especially in systems that enforce high-security hashing algorithms. While the impact on performance is small, it is more noticeable compared to shorter passwords."}, "scalability": {"score": 4, "rationale": "Passphrases scale well because they rely on the same infrastructure as simple passwords but with longer input lengths. The system''s ability to handle passphrases is largely the same as for regular passwords, but increased storage requirements may become an issue if the system has to manage large amounts of longer passphrase data."}, "auditability": {"score": 4, "rationale": "Passphrases offer solid auditability because they are treated similarly to traditional passwords, but their increased complexity and length may result in fewer login attempts and more secure logins. Systems can log attempts, failed logins, and changes to passphrases, but the audit trail doesn’t differ significantly from that of regular password systems."}, "availability": {"score": 4.5, "rationale": "Passphrases generally maintain high availability because they rely on the same infrastructure as simple passwords. The only factor that could slightly affect availability is the increased processing time for longer input, which can result in slightly higher system load when passphrases are widely used. However, this impact is minimal and does not significantly reduce availability."}, "confidentiality": {"score": 4, "rationale": "Passphrases provide strong confidentiality due to their complexity and length. A longer, complex passphrase is harder to brute-force, reducing the chances of compromise. When combined with additional security measures (e.g., hashing or salting), the confidentiality of the passphrase is further strengthened. However, if transmitted or stored insecurely, the confidentiality could still be at risk."}, "mfa_suitability": {"score": 3.5, "rationale": "Passphrases, while more secure than simple passwords due to their length and complexity, are still static. This makes them suitable for use as a first factor in MFA, but their strength is greatly enhanced when paired with another factor. They are a solid choice for MFA setups where users prefer memorable, complex phrases over shorter, complex passwords."}, "device_dependency": {"score": 1, "rationale": "Passphrases, like simple passwords, have minimal device dependency. Users can enter their passphrase on any device with a keyboard, and the system does not require any additional hardware or software for authentication. This keeps device dependency low, as passphrases function similarly to traditional passwords in terms of login mechanics."}, "security_strength": {"score": 3.5, "rationale": "Passphrases provide better security than traditional short passwords due to their length and complexity. They are harder to guess or brute-force, especially if users follow best practices (e.g., using multiple words, special characters). However, like other password-based methods, they are still vulnerable to phishing and credential theft if not combined with additional security measures like salting and hashing."}, "recovery_complexity": {"score": 4, "rationale": "Recovery for Passphrases is slightly more complex than simple passwords due to the increased length and complexity of the inputs. However, the reset process is largely the same as for simple passwords, with users going through a typical recovery mechanism (e.g., email verification or security questions). The added complexity comes primarily from users managing longer and more complex passphrases after recovery."}, "maintenance_complexity": {"score": 3.5, "rationale": "Passphrases introduce slightly more maintenance complexity compared to standard passwords due to the increased length and complexity of the inputs. Systems may require more frequent policy updates to accommodate user feedback, and additional storage may be needed for longer passphrases. However, once implemented, the maintenance is similar to that of standard passwords, with only small adjustments required over time."}, "resistance_to_phishing": {"score": 2, "rationale": "Passphrases offer little resistance to phishing because, like passwords, they can be phished by attackers. The only advantage is that passphrases are often longer and more complex, making them harder for users to type out incorrectly, but they still suffer from the same fundamental vulnerability to phishing as other static password methods."}, "third_party_dependency": {"score": 1, "rationale": "Passphrases, like simple passwords, have minimal third-party dependency. The system manages the authentication process entirely within its own infrastructure, and no external services are required to store or verify the passphrase. Any third-party involvement would be limited to hosting or infrastructure, unrelated to the authentication mechanism."}, "authentication_strength": {"score": 3.5, "rationale": "Passphrases increase authentication strength compared to simple passwords because they are generally longer and more complex, making them harder to guess or crack. The use of multiple words or phrases adds complexity, reducing the likelihood of successful brute-force attacks. However, like all static password methods, they can be vulnerable if captured or stolen, which limits the overall strength."}, "implementation_complexity": {"score": 3.5, "rationale": "Implementing passphrases is relatively simple from a technical perspective because they function similarly to passwords. However, the longer input length may require slight modifications to existing systems, such as supporting longer fields for storing passphrases and ensuring that hashing and storage mechanisms can handle the increased size. This adds a small amount of complexity compared to standard password implementation."}, "infrastructure_dependency": {"score": 2, "rationale": "Passphrases, despite being longer and more complex than standard passwords, require minimal additional infrastructure. The system needs only slight modifications to accommodate longer input fields and possibly more storage for the passphrases. However, the infrastructure dependency remains low, as the handling of passphrases is similar to that of traditional passwords."}}', 1) ON CONFLICT (id) DO NOTHING;
INSERT INTO public.security_patterns (id, name, description, properties, security_control) VALUES (10, 'Graphical Authentication', '{"intent": "Provide an alternative to traditional password authentication by using graphical elements, such as images or patterns, which are easier for users to remember and can enhance security by increasing complexity and reducing reliance on text-based passwords.", "problem": "How can a system authenticate users securely while offering an alternative that may be easier for users to remember and harder for attackers to guess, especially in environments where traditional passwords are inconvenient or less effective?", "solution": "Graphical Authentication uses images, patterns, or other visual elements for authentication. Users may be asked to select a series of images in a specific sequence, draw a pattern on a grid, or identify familiar objects within a set of random options. The system securely stores the graphical input (e.g., as a hashed pattern or selection sequence) and verifies it during login by comparing the user’s input with the stored data. This approach provides an alternative to alphanumeric passwords, leveraging human memory''s affinity for visual cues while making guessing attacks more challenging.", "consequences": {"negative": [{"factor": "Device Dependency", "reason": "Requires specific input interfaces, such as touchscreens or graphical displays, which may not be available on all devices."}, {"factor": "Usability Issues on Certain Devices", "reason": "Entering a graphical password may be more cumbersome on smaller screens or non-touch devices."}, {"factor": "Vulnerability to Shoulder Surfing", "reason": "Graphical inputs, especially patterns, may be visible to others if not entered discreetly, increasing the risk of observation attacks."}], "positive": [{"factor": "Enhanced Memorability", "reason": "Graphical passwords can be easier for users to remember than complex alphanumeric passwords, leveraging human ability to recall visual information."}, {"factor": "Reduced Susceptibility to Brute-Force Attacks", "reason": "Pattern or image-based inputs can increase complexity, making automated brute-force attacks more challenging."}, {"factor": "Device Compatibility", "reason": "Effective on devices with touchscreens, providing a user-friendly authentication option for mobile devices."}]}, "participants": {"human": [{"name": "User", "description": "The individual who creates a graphical password (e.g., a pattern, image sequence) and uses it for authentication."}], "non-human": [{"name": "Authentication System", "description": "Manages the creation, storage, and verification of graphical passwords."}, {"name": "Graphical Input Storage", "description": "Stores the hashed or encrypted representations of graphical inputs for authentication."}, {"name": "Input Interface", "description": "A user interface that allows users to create and enter graphical passwords, such as a grid for drawing patterns or an image selection screen."}]}}', '{"cost": {"score": 4, "rationale": "Graphical Passwords incur higher costs than text-based passwords because they require specialized infrastructure to handle graphical input (e.g., drawing patterns, selecting images). The system must store and verify graphical input, which is more resource-intensive compared to simple text-based passwords. Additionally, graphical systems may require more storage for images or patterns, increasing overall costs."}, "usability": {"score": 3.5, "rationale": "Graphical Passwords can be easier for some users to remember compared to complex text passwords, especially for those who are more visually oriented. However, inputting graphical passwords (e.g., selecting points on an image or drawing a pattern) can take longer than typing a short password, which impacts usability in environments where quick access is required."}, "compliance": {"score": 3.5, "rationale": "Graphical Passwords may face challenges in complying with some regulations, as they are less commonly used and may not fit easily into existing compliance frameworks. However, they can still meet basic security requirements, as long as strong storage and transmission protections are in place. The novelty of graphical input methods may lead to compliance gaps, especially if the system lacks well-defined security controls for graphical data."}, "performance": {"score": 3.5, "rationale": "Graphical Passwords require more processing compared to text-based passwords. Systems need to store and verify graphical input (e.g., patterns, points on images), which can be resource-intensive depending on the complexity of the graphical input method. Additionally, verifying graphical input requires more computational resources, which can affect performance, especially in systems with high traffic or resource constraints."}, "scalability": {"score": 4, "rationale": "Graphical Passwords can scale, but their increased storage requirements (e.g., for storing image selections or patterns) may add some complexity as the number of users increases. Additionally, graphical input mechanisms require more processing compared to text-based passwords, which can impact performance in very large systems."}, "auditability": {"score": 3.5, "rationale": "Graphical Passwords offer moderate auditability, but the nature of graphical input makes logging less straightforward. While systems can track login attempts, pattern selections, or image-based inputs, graphical interfaces are typically harder to audit in a detailed manner compared to text-based systems. However, standard logging around login success and failure, as well as user interactions with the graphical interface, can still provide useful insights."}, "availability": {"score": 3.5, "rationale": "Graphical Passwords require more complex infrastructure for input and verification (e.g., storing and processing images or patterns), which can affect availability, particularly in systems with high traffic. Additionally, graphical interfaces may require more resources and storage, potentially introducing bottlenecks in environments where performance or infrastructure capacity is a concern."}, "confidentiality": {"score": 3.5, "rationale": "Graphical Passwords offer moderate confidentiality, as they are more resistant to brute-force attacks due to their reliance on images or patterns. However, if graphical input is captured or stored insecurely, the confidentiality could be compromised. The use of unique graphical input offers an additional layer of complexity, but it does not prevent all forms of credential theft."}, "mfa_suitability": {"score": 3.5, "rationale": "Graphical Passwords offer an alternative to text-based passwords and are suitable for MFA. Their graphical nature adds an additional layer of complexity for attackers, making them harder to guess or crack. However, as a static factor, they still require the addition of another MFA factor (e.g., a token or biometric) to provide comprehensive security."}, "device_dependency": {"score": 2.5, "rationale": "Graphical Passwords introduce moderate device dependency, as users need a device that supports graphical input (e.g., touchscreens for pattern drawing or image selection). While most modern devices support these features, certain environments (e.g., older hardware or devices without graphical interfaces) may limit the usability of graphical passwords. Additionally, the user experience may differ depending on the device''s input capabilities, adding a degree of dependency on device compatibility."}, "security_strength": {"score": 3.5, "rationale": "Graphical passwords offer slightly better security than simple text-based passwords because they rely on images, patterns, or gestures, making brute-force and dictionary attacks more difficult. However, graphical passwords are vulnerable to shoulder-surfing and observation attacks, where an attacker watches the user input their password. Additionally, like traditional passwords, they can be vulnerable to phishing if the graphical input is not secured properly."}, "recovery_complexity": {"score": 3, "rationale": "Recovery complexity for Graphical Passwords is higher because resetting a graphical password often requires the system to reset or recreate the graphical input mechanisms, which can involve more steps than resetting a simple text-based password. Additionally, users may need extra assistance or guidance in resetting graphical patterns or images, as the process is less familiar to most users. Administrators must also ensure that the recovery process for graphical passwords remains secure, adding to the overall complexity."}, "maintenance_complexity": {"score": 2.5, "rationale": "Graphical Passwords introduce more maintenance complexity because they require specialized interfaces and infrastructure to manage and verify graphical inputs. Regular updates may be necessary to support new devices or interfaces, and additional monitoring is required to ensure the security and functionality of graphical password systems. Cross-compatibility and potential user experience issues also add to the maintenance burden, as systems need to be frequently tested and updated to ensure they work across all platforms."}, "resistance_to_phishing": {"score": 3, "rationale": "Graphical Passwords provide some resistance to phishing, as they require users to interact in a different way (e.g., selecting points on an image or drawing a pattern), which may be harder for attackers to replicate in a phishing attack. However, they are still vulnerable if the phishing attempt mimics the graphical interface well enough to trick users into providing their credentials."}, "third_party_dependency": {"score": 1, "rationale": "Graphical Passwords generally do not require third-party services to function. The system itself stores and processes the graphical inputs (e.g., patterns, images) without relying on external providers. As with other self-contained systems, the only potential third-party involvement is related to infrastructure hosting, not the authentication process itself."}, "authentication_strength": {"score": 3.5, "rationale": "Graphical Passwords offer moderate authentication strength as they are more difficult to brute-force due to their visual nature. However, they may be susceptible to shoulder-surfing and observation attacks, which can weaken their effectiveness. Additionally, while graphical passwords add diversity in authentication methods, they don’t inherently verify that the correct person is interacting with the system beyond recognizing the input pattern or images."}, "implementation_complexity": {"score": 2.5, "rationale": "Graphical Passwords have significantly higher implementation complexity because they require specialized user interfaces to capture and verify graphical input (e.g., drawing patterns, selecting images). The system must also securely store and process graphical data, which can be more complex than handling text-based passwords. Additionally, graphical input systems need to be cross-compatible across different devices and browsers, adding further implementation challenges."}, "infrastructure_dependency": {"score": 3, "rationale": "Graphical Passwords require more complex infrastructure to handle the input, storage, and verification of graphical data (e.g., patterns, images). This can necessitate specialized user interfaces and secure methods for processing and storing graphical inputs. Additionally, cross-device compatibility may require additional resources, increasing infrastructure dependency compared to text-based passwords."}}', 1) ON CONFLICT (id) DO NOTHING;
INSERT INTO public.security_patterns (id, name, description, properties, security_control) VALUES (1, 'Biometric Authentication', '{"intent": "Provide a secure and user-friendly method of authentication based on unique, measurable physical or behavioral characteristics, reducing reliance on passwords and preventing common attacks like phishing and credential theft.", "problem": "How can a system authenticate users based on something inherently unique to them, without requiring users to remember passwords or carry physical tokens, while ensuring security and user convenience?", "solution": "Biometric authentication relies on identifying users based on their unique biological traits, such as fingerprints, facial recognition, iris scans, or voice patterns. During authentication, the user provides a biometric input, which is captured and compared to a previously stored biometric template. If the captured biometric data matches the stored template, the system grants access. The biometric data is typically stored locally and encrypted to prevent exposure or misuse. The use of biometric data enhances security by providing a factor based on something inherent to the user.", "consequences": {"negative": [{"factor": "Privacy Concerns", "reason": "Storing and managing sensitive biometric data raises privacy issues, particularly if the data is compromised or misused."}, {"factor": "False Positives/Negatives", "reason": "Biometric systems are prone to errors such as false positives (incorrectly granting access) or false negatives (denying access to legitimate users)."}, {"factor": "Device Dependency", "reason": "Biometric authentication requires specific hardware for capturing biometric inputs, which may limit compatibility across different devices."}, {"factor": "Irrevocability", "reason": "Unlike passwords, biometric traits cannot be changed if compromised, raising concerns over long-term security."}], "positive": [{"factor": "Enhanced Security", "reason": "Biometric traits are difficult to forge or steal, offering a strong defense against credential theft and phishing attacks."}, {"factor": "Convenience", "reason": "Users do not need to remember passwords or carry physical tokens, improving the overall user experience."}, {"factor": "No Credential Reuse Risk", "reason": "Since biometric data is unique and personal to each individual, the risk of reusing compromised credentials across systems is eliminated."}, {"factor": "Global Accessibility", "reason": "Passwords can be used universally, requiring only text input capabilities."}]}, "participants": {"human": [{"name": "User", "description": "The individual who provides a biometric input for authentication."}], "nonHuman": [{"name": "Biometric Capture Device", "description": "A device (e.g., fingerprint scanner, facial recognition camera) that captures the user''s biometric input."}, {"name": "Authentication System", "description": "Compares the captured biometric data to the stored template and grants or denies access based on the match."}, {"name": "Biometric Database", "description": "Stores encrypted biometric templates for comparison during authentication."}]}}', '{"cost": {"score": 2, "rationale": "The costs of biometric hardware, secure storage, and specialized infrastructure make biometric authentication an expensive method to implement and maintain."}, "usability": {"score": 5, "rationale": "Highly user-friendly, as biometric systems require minimal effort from users, such as a simple fingerprint scan or facial recognition. Usability is limited by hardware availability."}, "compliance": {"score": 4, "rationale": "Biometric systems often meet compliance requirements in high-security environments. However, biometric data storage introduces additional privacy and regulatory concerns."}, "performance": {"score": 3, "rationale": "Performance depends on the biometric hardware and algorithms used. Modern systems are fast, but high-accuracy recognition or older devices can introduce delays."}, "scalability": {"score": 3, "rationale": "Scalability depends on the infrastructure required to support biometric hardware and securely store biometric data. Managing large-scale biometric databases can introduce operational challenges."}, "auditability": {"score": 3, "rationale": "Limited auditability for biometric events, as only the outcome (successful or failed match) is logged. More detailed tracking of biometric data usage may be complex."}, "availability": {"score": 4, "rationale": "Availability is generally high if the required biometric hardware is operational, but systems can be unavailable if hardware malfunctions or is missing."}, "confidentiality": {"score": 4, "rationale": "Confidentiality is strong if biometric data is securely stored and encrypted. However, breaches of biometric data are difficult to recover from, as biometric traits cannot be changed like passwords."}, "mfa_suitability": {"score": 5, "rationale": "Provides a strong, unique factor based on something you are, ideal for MFA."}, "device_dependency": {"score": 5, "rationale": "High device dependency. Biometric authentication requires specific hardware (e.g., fingerprint scanners, facial recognition systems) on the user''s device. If the biometric reader fails or is unavailable, authentication cannot proceed."}, "security_strength": {"score": 4, "rationale": "Biometric authentication provides strong security as it is based on unique biological traits, making it difficult to forge. However, it is vulnerable to biometric spoofing and forgery if the hardware is not secure."}, "recovery_complexity": {"score": 3, "rationale": "Biometric recovery is somewhat moderate. While biometrics cannot be ''lost,'' failures in recognition (e.g., due to hardware malfunction) may require fallback methods like passwords, which add complexity. Enrolling new biometric data also takes time."}, "maintenance_complexity": {"score": 3, "rationale": "Biometric systems require ongoing maintenance for hardware and software, as well as secure handling of biometric data. Maintaining accuracy and security over time can be challenging."}, "resistance_to_phishing": {"score": 5, "rationale": "Biometric data cannot be phished, making biometric authentication highly resistant to phishing attacks."}, "third_party_dependency": {"score": 1, "rationale": "No third-party dependency. Biometric systems generally do not rely on external providers unless integrated into a broader identity management system."}, "authentication_strength": {"score": 4, "rationale": "Strong authentication due to the uniqueness of biometric data, though spoofing and hardware vulnerabilities can reduce its reliability in some cases."}, "implementation_complexity": {"score": 4, "rationale": "Biometric systems are complex to implement due to the need for specialized hardware and secure integration with authentication systems."}, "infrastructure_dependency": {"score": 4, "rationale": "Requires secure storage of biometric templates and infrastructure for comparing captured biometrics to stored data."}}', 1) ON CONFLICT (id) DO NOTHING;
INSERT INTO public.security_patterns (id, name, description, properties, security_control) VALUES (3, 'Simple Password Authentication', '{"intent": "Enable user authentication by verifying a static password known to both the user and the system.", "problem": "How can a system authenticate users in a simple and widely understood way with minimal infrastructure?", "solution": "Users provide a password at login, and the system compares it against a stored value. The password must match the stored entry for authentication to succeed.", "consequences": {"negative": [{"factor": "Security Vulnerabilities", "reason": "Susceptible to brute-force attacks, phishing, and password reuse across systems. High probability of data theft due to missing salting or hashing."}, {"factor": "User Management", "reason": "Users may forget passwords, use weak passwords, or reuse them across platforms, increasing security risks."}, {"factor": "Productive Use", "reason": "Invaluable for productive use due to the minimal degree of security."}], "positive": [{"factor": "Simplicity", "reason": "Easy to implement and widely understood by users."}, {"factor": "Device-Agnostic", "reason": "Works across all devices without requiring specialized hardware or software."}, {"factor": "Cost-Effective", "reason": "Requires minimal infrastructure beyond secure password storage."}, {"factor": "Global Accessibility", "reason": "Passwords can be used universally, requiring only a text input."}]}, "participants": {"human": [{"name": "User", "description": "The individual who creates and enters the password to gain access to the system."}], "nonHuman": [{"name": "Authentication System", "description": "Compares the user-provided password with the stored one to verify access."}, {"name": "Password Storage", "description": "Stores the password or its hash for future verification."}]}}', '{"cost": {"score": 5, "rationale": "Simple Password Authentication is very cost-effective because it requires minimal infrastructure and resources. There is no need for complex systems beyond secure storage and verification of passwords. It''s a low-cost solution, especially for small to medium-sized systems, with the main expense being the setup of secure password storage."}, "usability": {"score": 4, "rationale": "Simple Password Authentication is very familiar and easy to use for most users. It requires minimal effort from the user (entering a static password), making it highly usable. However, usability can degrade if complex password policies (e.g., frequent password changes, special character requirements) are enforced."}, "compliance": {"score": 1, "rationale": "Simple Password Authentication often falls short of meeting modern compliance standards such as GDPR or PCI-DSS, which require stronger security measures like multi-factor authentication or hashed passwords. The lack of security mechanisms (e.g., no encryption or hashing) makes it difficult for this method to comply with regulations that mandate the protection of sensitive data."}, "performance": {"score": 5, "rationale": "Simple Password Authentication is highly performant because it involves minimal computational effort. Verifying a static password requires very little processing power or time, making it the most efficient in terms of speed. There are no additional steps like hashing or stretching, which ensures that performance remains high even with large numbers of users."}, "scalability": {"score": 4.5, "rationale": "Simple Password Authentication is highly scalable because it requires minimal infrastructure. The system only needs to handle password storage and verification, which can be easily scaled as the number of users increases. It’s straightforward to implement for large user bases with little impact on system resources."}, "auditability": {"score": 3.5, "rationale": "Simple Password Authentication offers basic auditability since systems can log login attempts, password changes, and failed login attempts. However, because passwords are static, there is limited visibility into the actual usage of the password beyond these events. The audit trail is straightforward but doesn''t provide much detail beyond success or failure of authentication."}, "availability": {"score": 5, "rationale": "Simple Password Authentication is highly available, as it does not rely on complex systems or additional infrastructure. It requires only basic password input and storage mechanisms, which are universally supported across all platforms. There are very few dependencies, making it robust and widely applicable with minimal downtime risks."}, "confidentiality": {"score": 2, "rationale": "Simple Password Authentication provides weak confidentiality because the password is stored and transmitted in a static form, making it vulnerable to interception, particularly if the system does not implement secure transmission protocols (e.g., TLS). Once the password is exposed, the user’s confidentiality is compromised."}, "mfa_suitability": {"score": 3.5, "rationale": "Simple Password Authentication is commonly used as one factor in Multi-Factor Authentication (MFA). While it serves as the ''something you know'' factor, its static nature means that it needs to be complemented with another factor (e.g., a token or biometric) to improve security. It is widely used in MFA but does not provide strong authentication on its own."}, "device_dependency": {"score": 1, "rationale": "Simple Password Authentication has minimal device dependency. Users can log in from any device that supports basic text input, making it universally accessible across platforms. The system does not rely on any specific hardware or device features, which keeps device dependency very low."}, "security_strength": {"score": 1, "rationale": "Simple password authentication relies solely on the user providing a static password. It is vulnerable to brute-force attacks, password reuse, phishing, and credential theft. Without any additional protections like hashing, salting, or multi-factor authentication (MFA), the security strength is inherently low. If attackers obtain the password, they can easily impersonate the user."}, "recovery_complexity": {"score": 5, "rationale": "Recovery for Simple Password Authentication is straightforward and well-established. Password reset mechanisms are easy to implement, and users are familiar with the process. Whether through email-based resets or security questions, the recovery process requires minimal effort, both from users and administrators, resulting in low complexity."}, "maintenance_complexity": {"score": 5, "rationale": "Simple Password Authentication has very low maintenance complexity. Once implemented, it requires minimal ongoing effort beyond regular updates and monitoring for vulnerabilities. Password policies may need adjustment over time, and password resets are common, but overall, it is easy to maintain due to its simplicity and widespread support."}, "resistance_to_phishing": {"score": 1, "rationale": "Simple Password Authentication is highly vulnerable to phishing attacks. Since users provide the same static password each time they log in, attackers can easily trick users into revealing their credentials through phishing schemes. Once the password is compromised, the attacker can impersonate the user without further barriers."}, "third_party_dependency": {"score": 1, "rationale": "Simple Password Authentication has minimal third-party dependency. All necessary components (password storage and verification) are typically handled by the system itself, without relying on external services. The only potential third-party involvement might be related to secure hosting or infrastructure, but the authentication process itself is self-contained."}, "authentication_strength": {"score": 1, "rationale": "Simple Password Authentication offers weak authentication strength as it relies on a static password. If the password is stolen or guessed, the attacker can easily impersonate the user. The authentication strength is entirely dependent on the quality of the password, meaning it can be strong with a complex password or weak with a simple one. However, there is no inherent mechanism to verify that the correct person is entering the password beyond knowing it."}, "implementation_complexity": {"score": 5, "rationale": "Simple Password Authentication is very easy to implement, requiring only basic password input, storage, and verification mechanisms. Most programming frameworks and libraries provide built-in support for this, and the infrastructure required is minimal. The only complexity lies in ensuring secure storage, but overall, it has one of the lowest implementation complexities among authentication methods."}, "infrastructure_dependency": {"score": 1, "rationale": "Simple Password Authentication requires minimal infrastructure. The system only needs basic components for password storage, hashing (if used), and verification. It does not require complex or specialized infrastructure, making it easy to implement on standard server setups. The dependency on infrastructure is very low."}}', 1) ON CONFLICT (id) DO NOTHING;
INSERT INTO public.security_patterns (id, name, description, properties, security_control) VALUES (4, 'Hashed Password Authentication', '{"intent": "Provide a secure method of storing passwords by hashing them before storage, thereby preventing plain-text password exposure in case of a data breach.", "problem": "How can a system securely store passwords in a way that prevents attackers from easily accessing the original passwords if the database is compromised?", "solution": "Hashed Password Storage involves applying a cryptographic hash function to each password before storing it in the database. When the user creates or updates a password, the system hashes the password and stores only the resulting hash. During login, the user’s input is hashed, and the resulting hash is compared to the stored hash to verify the password. This approach ensures that, even if the database is compromised, attackers cannot directly retrieve the original passwords.", "consequences": {"negative": [{"factor": "Vulnerability", "reason": "If hashing alone is used without additional security measures like salting, attackers may use precomputed hash tables (rainbow tables) to reverse-engineer common passwords."}, {"factor": "Low Security", "reason": "Simple hashing provides basic protection but is less secure than salted or stretched hashing methods."}, {"factor": "Requires a Strong Hash Function", "reason": "The choice of hashing algorithm is crucial; weaker algorithms (e.g., MD5) are susceptible to collisions and are no longer considered secure."}], "positive": [{"factor": "Slightly Enhanced Security", "reason": "Protects against plain-text password exposure since only hashes are stored."}, {"factor": "Simplicity", "reason": "Easy to implement and well-supported by standard cryptographic libraries."}, {"factor": "Device-Agnostic", "reason": "Works across different devices and environments without additional hardware."}]}, "participants": {"human": [{"name": "User", "description": "The individual who creates and inputs a password for authentication."}], "non-human": [{"name": "Authentication System", "description": "Hashes each password before storage and compares hashed inputs with stored hashes for authentication."}, {"name": "Password Storage", "description": "Stores the hashed passwords securely."}, {"name": "Hash Function", "description": "A secure cryptographic function (e.g., SHA-256, bcrypt) that converts the plain-text password to an irreversible hash."}]}}', '{"cost": {"score": 4, "rationale": "Hashed Password Storage is nearly as cost-effective as Simple Password Authentication. The only added cost comes from implementing the hashing algorithm to securely store passwords instead of saving them as plaintext. Like salted hashing, this requires minimal additional resources, making it a low-cost solution with strong security benefits."}, "usability": {"score": 4, "rationale": "Hashed Password Storage is transparent to users, as it does not change the process of logging in compared to Simple Password Authentication. Users continue to enter passwords as usual, and the hashing occurs behind the scenes. Usability remains high as long as the system does not impose burdensome password policies."}, "compliance": {"score": 3.5, "rationale": "Hashed Password Storage complies with most modern regulatory standards as long as strong hashing algorithms are used. Many compliance frameworks require that passwords are not stored in plaintext, and hashing is a widely accepted method for ensuring that passwords remain secure in storage, thus meeting compliance needs."}, "performance": {"score": 4.5, "rationale": "Hashed Password Storage has a similar performance impact as Salted Password Hashing. The hashing process requires more computational resources than simply storing a password in plaintext, but the overhead is minimal, and systems can handle the hashing efficiently. Performance is only slightly reduced compared to Simple Password Authentication."}, "scalability": {"score": 4.5, "rationale": "Hashed Password Storage is also highly scalable, as the process of hashing passwords and storing the resulting values does not require much additional infrastructure. It can be easily implemented across systems with a large number of users without a significant impact on performance or resources."}, "auditability": {"score": 4, "rationale": "Hashed Password Storage offers a similar level of auditability as Salted Password Hashing. Systems can log password-related events, and because passwords are hashed, audit logs are more secure from exposure. The audit trail remains clear and includes information on login success or failure, but like simple password methods, it lacks visibility into more detailed authentication behaviors."}, "availability": {"score": 5, "rationale": "Hashed Password Storage is also highly available, as it uses standard cryptographic techniques for password hashing that are widely supported and do not require specialized infrastructure. The hashing process does not impose significant performance overheads, ensuring that availability is not compromised, even in large-scale systems."}, "confidentiality": {"score": 3, "rationale": "Hashed Password Storage protects confidentiality better than storing passwords in plaintext but does not provide as strong protection as salted hashing. Without a salt, identical passwords across different accounts will result in the same hash, which could be exploited by attackers in case of a breach. However, it still ensures that plaintext passwords are not stored."}, "mfa_suitability": {"score": 3.5, "rationale": "Hashed Password Storage can be used effectively in MFA as the ''something you know'' factor. While it provides better protection than plaintext passwords, it still relies on the static nature of the password, making it less secure without other factors. However, it remains a suitable choice when combined with additional layers of security, such as ''something you have'' or ''something you are.''"}, "device_dependency": {"score": 1, "rationale": "Hashed Password Storage also involves minimal device dependency, as the hashing occurs on the server side, and users can authenticate from any device that supports basic login mechanisms. There is no need for specialized hardware or devices to support this form of authentication."}, "security_strength": {"score": 2, "rationale": "Hashed password storage provides better security than plaintext passwords, as passwords are stored in a hashed format. If an attacker gains access to the database, they would only obtain the hashed passwords. However, without a salt or additional complexity, hashed passwords are vulnerable to rainbow table attacks. Strong hashing algorithms improve security, but it’s still vulnerable to brute-force attacks."}, "recovery_complexity": {"score": 5, "rationale": "Hashed Password Storage presents little additional complexity in recovery compared to standard password systems. Users can recover passwords or reset them through typical recovery mechanisms without involving the hashed storage mechanism directly. The hashing process is abstracted from the user, so recovery is as simple as resetting a new password."}, "maintenance_complexity": {"score": 4, "rationale": "Hashed Password Storage is easy to maintain as it requires minimal ongoing management beyond ensuring that strong hashing algorithms are used and updated as needed. There are few moving parts, so maintenance complexity is low, though care must be taken to update algorithms and manage any potential weaknesses in the hashing mechanism over time."}, "resistance_to_phishing": {"score": 2, "rationale": "Hashed Password Storage has the same vulnerabilities to phishing as Simple Password Authentication. The hash protects the password from being easily reversed if it’s stolen from the server, but if the user is tricked into providing their password via phishing, it can still be used to log in as them."}, "third_party_dependency": {"score": 1, "rationale": "Hashed Password Storage, similar to salted hashing, does not require third-party services to function. The system handles all aspects of the hashing and password verification process. There is no need for external services to manage or validate passwords, keeping third-party dependency very low."}, "authentication_strength": {"score": 2, "rationale": "Hashed Password Storage ensures that passwords are not stored in plaintext, which prevents attackers from easily obtaining the password in case of a breach. However, the authentication strength is still tied to the strength of the user-chosen password and how well the hashing algorithm protects it. It does not add dynamic verification mechanisms, so if the password is compromised, the authentication can still be bypassed."}, "implementation_complexity": {"score": 4, "rationale": "Hashed Password Storage is slightly more complex than storing plaintext passwords but still relatively simple to implement. The system needs to apply a hashing algorithm to the password before storage, which is a standard practice. The complexity mainly comes from choosing and properly configuring a secure hashing algorithm (e.g., SHA-256, bcrypt). This additional step is well-supported by cryptographic libraries, so the overall complexity remains low."}, "infrastructure_dependency": {"score": 2, "rationale": "Hashed Password Storage requires slightly more infrastructure than storing plaintext passwords but still has low dependency. The system needs a secure environment to apply and store hashed passwords, but these are basic functions that most systems can easily handle. The overall infrastructure needs are only marginally higher than for simple password storage."}}', 1) ON CONFLICT (id) DO NOTHING;
INSERT INTO public.security_patterns (id, name, description, properties, security_control) VALUES (6, 'Key Stretching', '{"intent": "Increase the computational cost of password hashing to protect against brute-force and dictionary attacks, especially when attackers use high-performance hardware to attempt password cracking.", "problem": "How can a system make password hashes more resistant to brute-force attacks, even when attackers have significant computational resources?", "solution": "Key-Stretching applies a hash function multiple times (or uses a resource-intensive function) on a password to make each attempt at guessing the password more time-consuming and computationally expensive. This is commonly achieved using algorithms like bcrypt, PBKDF2, or scrypt, which require additional processing time or memory. During password creation, the system applies multiple iterations of hashing to the password and stores the resulting hash. During login, the password is hashed in the same way, and the result is compared to the stored hash. This method effectively increases the cost of each hashing attempt for potential attackers.", "consequences": {"negative": [{"factor": "Increased Processing Time", "reason": "The additional hashing iterations require more computational resources, potentially slowing down authentication for users."}, {"factor": "Higher Resource Requirements", "reason": "Can impact server performance, particularly in high-traffic environments or when processing large volumes of authentication requests."}, {"factor": "Complexity in Tuning", "reason": "Requires careful tuning to balance security and performance, as excessive key-stretching can affect usability."}], "positive": [{"factor": "Higher Security", "reason": "Increases resistance to brute-force and dictionary attacks by making each hashing attempt computationally expensive compared to salted and hashed password authentication."}, {"factor": "Scalable Difficulty", "reason": "Parameters for key-stretching algorithms can be adjusted to remain secure as computational power increases over time."}, {"factor": "Device-Agnostic", "reason": "Can be implemented on various devices and systems without additional hardware."}]}, "participants": {"human": [{"name": "User", "description": "The individual who creates and enters a password that will undergo key-stretching during storage and verification."}], "non-human": [{"name": "Authentication System", "description": "Applies the key-stretching process to hash passwords and verifies user passwords by applying the same hashing process during login."}, {"name": "Device", "description": "Stores the hashed and stretched passwords securely."}, {"name": "Key-Stretching Algorithm", "description": "A secure algorithm (e.g., bcrypt, PBKDF2, or scrypt) that repeatedly hashes the password, making brute-force attacks more difficult."}]}}', '{"cost": {"score": 4.5, "rationale": "Key-Stretching increases costs compared to simple hashing because it requires more computational resources to perform multiple iterations of hashing. This adds complexity to the infrastructure, especially for systems with large user bases where the repeated hashing must occur frequently. While the cost is not prohibitive, it is higher due to the increased processing load."}, "usability": {"score": 3, "rationale": "Key-Stretching introduces some delays in the authentication process due to the repeated hashing of the password, which can slightly reduce the perceived performance. While users may not notice a significant difference, slower systems or high-load environments could make this approach feel less responsive, impacting usability."}, "compliance": {"score": 4.5, "rationale": "Key-Stretching significantly improves compliance with regulations that require robust password protection mechanisms, such as NIST SP 800-63B and PCI-DSS. Key-stretching ensures that even weak passwords are protected by making brute-force attacks computationally expensive, which is often required by security compliance standards."}, "performance": {"score": 3.5, "rationale": "Key-Stretching introduces more significant computational overhead due to the repeated hashing of the password. This process slows down both the initial authentication and any processes that require hashing. The impact is especially noticeable in systems with large user bases or high-frequency authentication requests, as each authentication requires more processing time."}, "scalability": {"score": 4, "rationale": "Key-Stretching, while adding security, introduces some computational overhead due to repeated hashing, which can slightly reduce scalability in high-traffic systems. Although it can still scale well, the extra computational effort for each login increases the load on the system, especially when the number of users grows rapidly."}, "auditability": {"score": 4.5, "rationale": "Key-Stretching enhances auditability by increasing the security around password storage and making it more resistant to attacks. Systems that use key-stretching can log password attempts and the time taken for hashing, providing additional insights into system performance during authentication. This helps security teams audit both login behaviors and potential attack attempts (e.g., brute force), adding a layer of detail to the audit logs."}, "availability": {"score": 4.5, "rationale": "Key-Stretching slightly reduces availability compared to basic hashing because it introduces additional computational steps, which may cause delays during high-traffic periods. While the impact on performance is generally small, it could affect availability in environments with large user bases or resource-constrained systems, as key-stretching algorithms require more processing time."}, "confidentiality": {"score": 4, "rationale": "Key-Stretching adds additional protection to password confidentiality by making brute-force attacks on hashed passwords computationally expensive. Even if attackers access the hashed passwords, the repeated hashing process makes it much harder to crack weak passwords, protecting the confidentiality of the user’s credentials."}, "mfa_suitability": {"score": 4, "rationale": "Key-Stretching enhances the security of passwords by making them more resistant to brute-force attacks, which improves their suitability as part of an MFA scheme. While the password itself remains static, key-stretching makes it much harder for attackers to compromise the ''something you know'' factor, making it a strong choice in MFA systems."}, "device_dependency": {"score": 1, "rationale": "Key-Stretching remains device-agnostic since the computational burden is on the server. The user''s device does not need to have any special capabilities beyond the ability to submit a password. The device dependency is very low, and users can log in from virtually any device without issues related to hardware compatibility."}, "security_strength": {"score": 3, "rationale": "Key-stretching (e.g., using PBKDF2, bcrypt, or scrypt) adds significant security by applying the hashing function repeatedly, making brute-force and dictionary attacks computationally expensive. Key-stretching strengthens weak passwords by increasing the time it takes to compute each hash, significantly slowing down potential attacks. However, it doesn''t inherently protect against phishing or credential theft but makes password cracking much harder."}, "recovery_complexity": {"score": 4, "rationale": "Key-Stretching introduces slightly more complexity during recovery because the system must handle the computational load associated with generating secure, stretched passwords during the reset process. However, the user experience remains the same as in traditional password systems. Administrators may need to ensure that the reset process remains performant, especially in systems with high traffic."}, "maintenance_complexity": {"score": 3.5, "rationale": "Key-Stretching increases maintenance complexity because it requires careful tuning to ensure the hashing process remains both secure and performant. Over time, the system may need adjustments as hardware improves and password-cracking techniques evolve, requiring retuning of the key-stretching algorithm to balance security and performance. Monitoring resource usage and performance also adds to the ongoing complexity."}, "resistance_to_phishing": {"score": 2, "rationale": "Key-Stretching increases password security against brute-force attacks but does little to prevent phishing attacks. Users still provide a static password when logging in, which can be phished. The strength of key-stretching lies in making the password difficult to crack, not in protecting it from being stolen by phishing."}, "third_party_dependency": {"score": 1, "rationale": "Key-Stretching does not rely on third parties to function, as the process of applying multiple hash iterations is done entirely within the system itself. There are no dependencies on external services for authentication, except for potential infrastructure or hosting, which is unrelated to the authentication mechanism."}, "authentication_strength": {"score": 3, "rationale": "Key-Stretching improves authentication strength by significantly increasing the time and computational effort needed to brute-force or guess a password. This makes weak passwords much harder to crack. Although the authentication still relies on a static password, the increased computational complexity of attacks on the password increases the overall strength of the authentication process."}, "implementation_complexity": {"score": 3.5, "rationale": "Key-Stretching introduces more complexity compared to simple hashing, as it requires the system to apply the hashing algorithm multiple times (e.g., using bcrypt, PBKDF2, or scrypt). Implementing key-stretching properly requires additional setup and tuning to ensure the correct balance between security and performance. The increased computational cost can also require more careful management of resources, especially in high-traffic environments."}, "infrastructure_dependency": {"score": 2.5, "rationale": "Key-Stretching adds infrastructure dependency because it requires more computational power for each authentication attempt. The system must perform multiple iterations of hashing, which can put a strain on server resources, especially with a large number of users or frequent logins. The infrastructure needs to support this additional computational load, slightly increasing dependency compared to standard hashing."}}', 1) ON CONFLICT (id) DO NOTHING;
INSERT INTO public.security_patterns (id, name, description, properties, security_control) VALUES (5, 'Salted Password Hashing', '{"intent": "Strengthen password storage security by using unique salts to make each hashed password unique, even if two users have the same password, protecting against rainbow table and precomputed hash attacks.", "problem": "How can a system securely store passwords to prevent attackers from easily deriving the original passwords if the database is compromised, especially when multiple users may share common passwords?", "solution": "Salted Password Hashing adds a unique, random salt to each password before hashing it. When the user creates or updates their password, the system generates a salt and combines it with the password before hashing the result. The hashed password and its unique salt are stored together. During login, the user’s password is combined with the stored salt and hashed, and the resulting hash is compared to the stored hash. This method ensures that even if two users have identical passwords, their stored hashes will differ.", "consequences": {"negative": [{"factor": "Slightly Increased Storage Needs", "reason": "Each password entry requires additional storage for the salt."}, {"factor": "Moderate Implementation Complexity", "reason": "Requires secure salt generation and storage alongside hashed passwords."}, {"factor": "Requires Secure Hashing Algorithm", "reason": "Hashing algorithms must be strong (e.g., bcrypt, PBKDF2) to avoid vulnerabilities that could undermine the effectiveness of the salt."}], "positive": [{"factor": "Slightly Enhanced Security", "reason": "Protects against rainbow table attacks by making each password hash unique through the addition of salts."}, {"factor": "Reduced Risk of Password Reuse Exploits", "reason": "Even if multiple users have the same password, each hash will be unique due to the salt."}, {"factor": "Device-Agnostic", "reason": "Functions across various devices without additional hardware."}]}, "participants": {"human": [{"name": "User", "description": "The individual who creates and enters a password to access the system."}], "non-human": [{"name": "Authentication System", "description": "Generates a unique salt for each password, hashes the salted password, and verifies user-provided passwords against stored hashes."}, {"name": "Password Storage", "description": "Stores the hashed passwords and their unique salts securely"}, {"name": "Random Salt Generator", "description": "A function or component within the system that generates secure, unique salts for each password."}]}}', '{"cost": {"score": 4, "rationale": "Salted Password Hashing introduces slightly more cost than simple password authentication due to the need to generate and store unique salts for each password. However, the additional costs are minimal since salting and hashing can be implemented with standard cryptographic libraries, and the storage of salts does not significantly increase resource requirements."}, "usability": {"score": 4, "rationale": "Password Hashing does not directly impact the user''s experience, as the process of salting and hashing happens in the background. For the user, the experience is very similar to Simple Password Authentication, but the added security requirements may slightly increase complexity for administrators."}, "compliance": {"score": 3.5, "rationale": "Salted Password Hashing aligns well with most compliance standards, including PCI-DSS and GDPR, which require that passwords be protected against easy retrieval in case of a breach. The use of a salt and strong hashing algorithms ensures that stored passwords meet many regulatory requirements for secure storage and handling of credentials."}, "performance": {"score": 4.5, "rationale": "Salted Password Hashing introduces a small performance overhead compared to simple password authentication. The need to generate a salt and compute the hash for each password increases processing time slightly. However, the impact on performance is minimal, and modern systems can handle the additional computations efficiently. Thus, it is still highly performant, with only a slight delay compared to basic password authentication."}, "scalability": {"score": 4.5, "rationale": "Salted Password Hashing scales well, as the additional computation required for hashing and storing the salt does not significantly affect scalability. The system can handle large volumes of users efficiently, with only slight overhead from managing the salts. This makes it suitable for systems with growing user bases."}, "auditability": {"score": 4, "rationale": "Salted Password Hashing improves auditability by providing more secure logging of password-related events. Systems can audit password creation (salt generation), password changes, and failed login attempts with more confidence that credentials are securely stored. The use of salts adds complexity but doesn’t affect logging mechanisms, making it easy to track authentication attempts without compromising security."}, "availability": {"score": 5, "rationale": "Salted Password Hashing remains highly available because the additional step of generating and storing salts is computationally lightweight and has minimal impact on the system''s ability to handle large numbers of users. The infrastructure required is still basic, and adding salts does not introduce significant operational dependencies that would affect availability."}, "confidentiality": {"score": 3.5, "rationale": "Salted Password Hashing improves confidentiality by ensuring that even if attackers access the password database, they cannot easily reverse the hashes to reveal the actual passwords. The salt ensures that identical passwords have different hash values, reducing the risk of mass compromise in the event of a breach. However, phishing and poor transmission security can still expose the password."}, "mfa_suitability": {"score": 4, "rationale": "Salted Password Hashing is more secure than simple password authentication, making it a good candidate for MFA. The additional protection provided by hashing and salting reduces the likelihood of password theft, making it a stronger first factor in MFA setups. It works well alongside other factors (e.g., tokens or biometrics) to form a robust authentication scheme."}, "device_dependency": {"score": 1, "rationale": "Salted Password Hashing, like Simple Password Authentication, has very low device dependency. The process of generating salts and hashing passwords happens server-side, meaning users can authenticate from any device without requiring specific hardware. The system itself handles all security operations without placing extra demands on the user''s device."}, "security_strength": {"score": 2.5, "rationale": "Salted password hashing improves security by adding a random salt to each password before hashing. This protects against rainbow table attacks, where attackers use precomputed hash tables to reverse weak passwords. However, salted passwords are still vulnerable to brute-force attacks, especially if weak passwords are used. The hashing itself does not add any additional authentication strength but makes cracking individual passwords more difficult."}, "recovery_complexity": {"score": 5, "rationale": "Recovery complexity for Salted Password Hashing is similar to Simple Password Authentication because the recovery process does not involve the salts themselves. Users can reset their passwords easily through conventional means (e.g., email verification). The system''s handling of salts during a reset does not add significant complexity, as it generates new salts automatically during password changes."}, "maintenance_complexity": {"score": 4, "rationale": "Salted Password Hashing introduces a bit more maintenance complexity compared to simple password storage due to the need to manage salts alongside the passwords. However, most cryptographic libraries handle salt generation and storage automatically, reducing the maintenance burden. Regular updates to hashing algorithms may be required to maintain security standards, but the day-to-day maintenance remains low."}, "resistance_to_phishing": {"score": 2, "rationale": "Salted Password Hashing provides minimal additional resistance to phishing because the user still enters a static password during login. While the salt protects the password once it’s stored in the system, it does not protect against phishing attempts where users are tricked into sharing their passwords. The strength here comes from how the password is handled on the server side, not from the interaction itself."}, "third_party_dependency": {"score": 1, "rationale": "Salted Password Hashing, like Simple Password Authentication, involves very little third-party dependency. The system manages the salting, hashing, and storage of passwords internally, without needing external services. Any additional third-party involvement is likely related to hosting or infrastructure rather than the authentication mechanism itself."}, "authentication_strength": {"score": 2, "rationale": "Salted Password Hashing slightly improves authentication strength over simple password authentication by preventing attackers from using precomputed hash tables. However, it still does not increase the inherent authentication strength beyond protecting against hash-based attacks. The user still needs to remember and input a password, meaning the authentication relies on the strength of that password."}, "implementation_complexity": {"score": 4, "rationale": "Salted Password Hashing adds a small amount of implementation complexity compared to simple password storage because it requires the generation of a unique salt for each password and storing the salt alongside the hashed password. However, most modern libraries offer built-in support for salted hashing, and the additional complexity is manageable, making it straightforward to implement securely."}, "infrastructure_dependency": {"score": 2, "rationale": "Salted Password Hashing introduces a small increase in infrastructure dependency due to the need to store unique salts alongside hashed passwords. However, the infrastructure required to handle salted hashing is minimal and can be supported by most standard server environments. The additional complexity only slightly increases the infrastructure dependency compared to simple password storage."}}', 1) ON CONFLICT (id) DO NOTHING ;
INSERT INTO public.security_patterns (id, name, description, properties, security_control) VALUES (7, 'Challenge-Response Password Authentication', '{"intent": "Enable secure authentication by verifying that the user possesses a secret (password or key) without directly transmitting it over the network, thereby reducing exposure to interception and replay attacks.", "problem": "How can a system authenticate a user without transmitting their actual password over the network, thus protecting against eavesdropping and replay attacks?", "solution": "Challenge-Response Password Authentication involves the system generating a unique, time-bound challenge (e.g., a random number or nonce) that is sent to the user. The user’s client application (or the user themselves) combines this challenge with their secret (e.g., password or private key) and performs a cryptographic operation (e.g., hashing, signing) to produce a response. The response is sent back to the server, which performs the same operation using the stored user secret to verify the response. This approach ensures that the actual password or secret is never transmitted, providing a secure means of authentication resistant to replay and interception.", "consequences": {"negative": [{"factor": "Increased Complexity", "reason": "Requires additional infrastructure to generate, manage, and validate unique challenges for each session."}, {"factor": "Requires Cryptographic Operations", "reason": "Necessitates secure cryptographic functions on both the client and server, which may add computational overhead."}, {"factor": "Device Dependency", "reason": "May require specialized client software or secure storage for cryptographic keys, which can introduce compatibility challenges."}], "positive": [{"factor": "Higher Security", "reason": "Protects against eavesdropping and replay attacks by ensuring the secret is never transmitted directly."}, {"factor": "Resistant to Phishing", "reason": "Reduces the risk of the secret being captured through phishing, as each challenge-response exchange is unique."}, {"factor": "Compatible with Multi-Factor Authentication (MFA)", "reason": "Can be effectively used alongside other factors to create a robust MFA setup."}]}, "participants": {"human": [{"name": "User", "description": "The individual who possesses the secret (password or key) and participates in the challenge-response authentication."}], "non-human": [{"name": "Authentication System", "description": "Generates a unique challenge, verifies the user’s response, and authenticates the user based on the validity of the response."}, {"name": "Challenge Generator", "description": "Generates a unique, time-sensitive challenge for each authentication attempt."}, {"name": "Client Application", "description": "Performs the cryptographic operation to create the response based on the challenge and the user’s secret."}, {"name": "Secret Storage", "description": "Stores hashed or encrypted representations of the user’s secrets for verification purposes."}]}}', '{"cost": {"score": 3, "rationale": "Challenge-Response Authentication introduces higher costs because it requires the system to generate dynamic challenges and validate responses, which is more complex than simply verifying a static password. Additionally, the infrastructure needed to support challenge-response mechanisms can be more expensive to develop and maintain, increasing both implementation and operational costs."}, "usability": {"score": 2.5, "rationale": "Challenge-Response Authentication requires additional steps from the user compared to static password entry. Users must interact with the system by responding to dynamic challenges, which can be confusing or time-consuming, especially for less tech-savvy individuals. This reduces overall usability compared to simpler methods."}, "compliance": {"score": 4.5, "rationale": "Challenge-Response Authentication is highly compliant with many security standards that emphasize protecting credentials in transmission, such as GDPR, ISO 27001, and HIPAA. By preventing direct transmission of static passwords and using dynamic challenges, this method addresses compliance requirements for securing data in transit and mitigating replay attacks."}, "performance": {"score": 3.5, "rationale": "Challenge-Response Authentication requires the generation of dynamic challenges and verification of responses, adding complexity to the authentication process. The system needs to compute a new challenge for each session and verify the user’s response, which requires more processing than simply verifying a static password. This can reduce performance, especially in systems with high volumes of authentication requests."}, "scalability": {"score": 4, "rationale": "Challenge-Response Authentication requires more complex interactions between the client and server, including dynamic challenge generation and verification. This added complexity can make the system harder to scale efficiently, as each authentication session involves multiple steps. This results in more resources being required as the user base grows."}, "auditability": {"score": 4.5, "rationale": "Challenge-Response Authentication offers strong auditability, as it logs dynamic challenges and user responses, which provides detailed insights into each authentication attempt. Since the system generates unique challenges for every session, auditing can include information about the validity of challenges and responses, replay attack attempts, and overall system health. This richer logging enhances audit capabilities, particularly in security-focused environments."}, "availability": {"score": 3.5, "rationale": "Challenge-Response Authentication relies on more complex interactions between the client and server, including the generation and verification of dynamic challenges. This additional complexity can affect availability, especially during high load conditions or in cases where the server needs to maintain real-time communication with the client to complete the authentication process."}, "confidentiality": {"score": 4.5, "rationale": "Challenge-Response Authentication provides strong confidentiality because the password is never directly transmitted during authentication. Instead, the system uses a dynamic challenge that must be correctly answered, preventing attackers from intercepting or stealing the password during transmission. This dynamic approach greatly enhances confidentiality."}, "mfa_suitability": {"score": 5, "rationale": "Challenge-Response Authentication is highly suitable for MFA because it adds a dynamic aspect to the authentication process, preventing replay attacks and making the ''something you know'' factor more resilient. It works well as part of an MFA setup, especially when paired with other authentication methods like tokens or biometrics, to create a secure, multi-layered defense."}, "device_dependency": {"score": 3.5, "rationale": "Challenge-Response Authentication introduces some level of device dependency because the user must interact dynamically with the system to respond to challenges. In some cases, this might require specialized software or specific devices (e.g., smartcards or tokens) to handle the challenge-response mechanism, especially in high-security environments. While the basic concept can work on most devices, more secure implementations may increase the dependency on certain hardware."}, "security_strength": {"score": 4, "rationale": "Challenge-response password authentication enhances security by introducing a dynamic challenge that the user must respond to, preventing replay attacks and ensuring that passwords are not reused across sessions. It provides better security than static passwords because passwords are never directly transmitted over the network. This method is resilient against many attacks, including phishing and credential theft, but requires secure implementation."}, "recovery_complexity": {"score": 3.5, "rationale": "Recovery complexity is higher in Challenge-Response Authentication because the dynamic nature of the authentication process requires more effort to reset or recover. The system must issue new challenges or reset the challenge-response mechanism. Administrators must ensure that reset mechanisms cannot be exploited by attackers (e.g., issuing valid responses for previously compromised challenges), adding more complexity than a simple password reset."}, "maintenance_complexity": {"score": 3, "rationale": "Challenge-Response Authentication introduces more maintenance complexity due to the dynamic nature of the authentication process. The system must consistently generate and validate unique challenges, which requires monitoring for security vulnerabilities and performance issues. Additionally, any changes to the underlying cryptographic methods will require updates across the challenge-response system, increasing the maintenance burden."}, "resistance_to_phishing": {"score": 4, "rationale": "Challenge-Response Authentication is highly resistant to phishing attacks. Since the system generates a unique challenge each time and the user’s password is not directly transmitted, an attacker cannot simply steal and reuse the password. Even if an attacker obtains the user’s response to a challenge, it is tied to that specific session and cannot be reused."}, "third_party_dependency": {"score": 3, "rationale": "Challenge-Response Authentication introduces some third-party dependency, particularly if external hardware or services are required for generating or validating the challenges (e.g., tokens or secure challenge servers). While the system can manage the challenges internally, more complex or high-security implementations may depend on third-party services for challenge generation or response validation, increasing reliance on external systems."}, "authentication_strength": {"score": 4, "rationale": "Challenge-Response Authentication provides strong authentication because the system verifies not only that the user knows the password but that they can correctly respond to a dynamic challenge. This process prevents replay attacks and ensures that the user has real-time access to the password, significantly boosting authentication strength. It’s less vulnerable to traditional credential theft and reuse."}, "implementation_complexity": {"score": 3, "rationale": "Challenge-Response Authentication involves more implementation complexity due to the need for generating unique challenges for each authentication attempt and verifying the user’s response. This requires more sophisticated logic and communication between the client and server. The system must also securely manage the exchange of challenge data, which adds further complexity compared to static password verification."}, "infrastructure_dependency": {"score": 3, "rationale": "Challenge-Response Authentication requires more sophisticated infrastructure, including the capability to generate, store, and validate dynamic challenges. This process may involve secure communication channels between the server and the client, adding complexity to the infrastructure. Additionally, systems may need specialized hardware or software to handle the challenge-response mechanism securely, further increasing infrastructure dependency."}}', 1) ON CONFLICT (id) DO NOTHING;
INSERT INTO public.security_patterns (id, name, description, properties, security_control) VALUES (8, 'Password-Based One-Time Password (POTP) Authentication', '{"intent": "Provide secure, time-sensitive authentication by generating a one-time password that is valid for a single session or transaction, reducing the risk of credential theft and replay attacks.", "problem": "How can a system ensure that a user can authenticate securely without relying on a static password, which may be vulnerable to interception, reuse, or replay attacks?", "solution": "POTP Authentication generates a unique, temporary password that is valid for a single session or transaction. The OTP can be generated based on time (e.g., Time-Based One-Time Password, TOTP) or an event (e.g., HMAC-Based One-Time Password, HOTP). The system generates the OTP and delivers it to the user via an out-of-band channel, such as a mobile app, SMS, or email. The user enters the OTP as part of the login process, and the system verifies the OTP by recalculating the expected value using a shared secret and current time or event. Once verified, the OTP cannot be reused, thus mitigating risks associated with replay attacks.", "consequences": {"negative": [{"factor": "Device Dependency", "reason": "POTP often requires the user to have access to a specific device (e.g., smartphone) to receive or generate the OTP, which may cause issues if the device is lost or unavailable."}, {"factor": "Vulnerable Delivery Channels", "reason": "If the delivery channel (e.g., SMS) is compromised, an attacker could intercept the OTP, reducing security."}, {"factor": "Limited Usability", "reason": "Users may find it inconvenient to retrieve and enter a new OTP for each session, especially if the delivery method is slow or unreliable."}, {"factor": "Implementation Complexity", "reason": "Requires infrastructure for securely generating and delivering OTPs, as well as managing shared secrets for time-based algorithms."}], "positive": [{"factor": "Enhanced Security", "reason": "Each OTP is valid for only a short time or single transaction, reducing the risk of credential theft, phishing, and replay attacks."}, {"factor": "No Password Reuse", "reason": "Since the OTP changes with each session, there is no risk of reusing a compromised credential."}, {"factor": "Out-of-Band Delivery", "reason": "Using a separate delivery channel (e.g., SMS or app) creates an additional layer of security."}]}, "participants": {"human": [{"name": "User", "description": "The individual who receives and enters the one-time password during authentication."}], "non-human": [{"name": "OTP Generator", "description": "A component within the system or a secure app that generates the OTP using a time-based or event-based algorithm."}, {"name": "Authentication System", "description": "Verifies the OTP by recalculating the expected value and comparing it with the user-provided OTP."}, {"name": "Delivery Channel", "description": "The method by which the OTP is delivered to the user, such as SMS, email, or a mobile authenticator app."}, {"name": "Secret Storage", "description": "Stores the shared secret securely, used to validate the OTP during authentication."}]}}', '{"cost": {"score": 2.5, "rationale": "POTP is relatively costly because it requires infrastructure to generate and validate one-time passwords, as well as possibly delivering OTPs via external channels (e.g., SMS, email, or mobile apps). This adds overhead in terms of both development and ongoing operational costs, especially when dealing with secure delivery mechanisms for OTPs."}, "usability": {"score": 2.5, "rationale": "POTP adds complexity for users, as they need to generate or receive a new OTP for each login attempt, which requires an additional device or method (e.g., phone app or SMS). While it improves security, it introduces friction for users, reducing the ease of use."}, "compliance": {"score": 4.5, "rationale": "POTP is very compliant with most modern regulations that require strong, dynamic authentication mechanisms, such as PSD2, GDPR, and PCI-DSS. Since each password is only valid for a single use, the risk of password theft or reuse is minimized, aligning well with regulatory requirements for secure user authentication and transaction validation."}, "performance": {"score": 3, "rationale": "POTP introduces more performance overhead due to the need to generate, transmit, and verify one-time passwords. The infrastructure required to deliver OTPs (e.g., SMS, email, or app-based) and the verification process adds delays compared to static passwords. The performance impact is especially noticeable when dealing with large user bases or when OTP delivery is slow due to network issues or system load."}, "scalability": {"score": 3.5, "rationale": "POTP requires additional infrastructure to generate and validate one-time passwords, which adds complexity to the system. While the OTP mechanism can scale, it requires more resources and management (e.g., delivering OTPs securely via SMS, email, or an app) compared to static password authentication. As the user base grows, the overhead of managing OTP generation and transmission can become significant."}, "auditability": {"score": 4.5, "rationale": "POTP provides strong auditability due to the generation and verification of one-time passwords. Systems can log each OTP generation, delivery method (e.g., SMS, email), and validation, giving administrators insight into the authentication process. Audit logs can also track failed OTP attempts, delivery issues, and whether any OTPs were compromised, making it easier to trace potential security breaches or attacks."}, "availability": {"score": 5, "rationale": "POTP requires the system to generate, distribute, and verify one-time passwords, which introduces additional dependencies on external services (e.g., SMS or email for OTP delivery) or mobile applications. These dependencies can affect availability if the OTP delivery channels experience outages or delays, potentially leading to users being unable to authenticate in a timely manner."}, "confidentiality": {"score": 4.5, "rationale": "POTP ensures high confidentiality because the password is only valid for a single session or transaction, making it less valuable if intercepted. Even if the OTP is compromised, it cannot be reused. This dynamic nature of the authentication mechanism protects the user''s credentials and limits the exposure of sensitive data."}, "mfa_suitability": {"score": 4.5, "rationale": "POTP is particularly well-suited for MFA because it introduces a dynamic, one-time password that enhances security. When used in MFA, it can serve as both the ''something you know'' and a dynamic component of the authentication process. It significantly improves security when combined with other factors, such as a hardware token or biometric input."}, "device_dependency": {"score": 4, "rationale": "POTP increases device dependency significantly, as it often requires users to have a specific device (e.g., a mobile phone, hardware token, or an app) to receive or generate the one-time password. If users lose access to this device, they may be unable to authenticate. The reliance on external devices for OTP delivery makes this method more dependent on the availability of these devices and their functionality."}, "security_strength": {"score": 4, "rationale": "Password-Based OTP significantly enhances security by generating temporary, one-time passwords (OTPs) that expire after a single use. This minimizes the risk of replay attacks and credential reuse. Since the password changes for each authentication attempt, even if the OTP is stolen, it cannot be reused. This method is highly resistant to phishing and brute-force attacks but requires secure transmission of the OTP."}, "recovery_complexity": {"score": 3, "rationale": "Recovering from a lost OTP mechanism (e.g., a phone or device used for OTP generation) is more complex than traditional password recovery. The system must verify the user''s identity and provide a new OTP generation method, which often requires additional security measures. This process can involve additional steps like verifying backup codes or using alternative contact methods, making recovery more involved than simple password-based systems."}, "maintenance_complexity": {"score": 2.5, "rationale": "POTP adds significant maintenance complexity because the system must manage the infrastructure for generating, transmitting, and verifying one-time passwords. This includes handling issues with delivery (e.g., SMS or email failures), monitoring expiration times for OTPs, and managing potential conflicts with OTP resends or retries. Additionally, any third-party integrations (e.g., SMS providers) require ongoing management and monitoring."}, "resistance_to_phishing": {"score": 4.5, "rationale": "POTP is very resistant to phishing because the password changes with each login attempt. Even if an attacker successfully phishes an OTP, it cannot be reused since it is only valid for a single session or transaction. This dynamic nature of the password significantly reduces the impact of phishing attacks."}, "third_party_dependency": {"score": 3.5, "rationale": "POTP has a higher level of third-party dependency because it often requires external services to deliver OTPs (e.g., via SMS, email, or mobile apps). Many systems rely on third-party providers for sending OTPs securely, meaning that the system''s ability to authenticate users depends on the availability and reliability of these external services. This increases third-party dependency significantly."}, "authentication_strength": {"score": 4, "rationale": "POTP provides very high authentication strength by ensuring that the password is only valid for a single transaction or session. Even if an attacker captures the OTP, they cannot reuse it. The dynamic nature of OTPs combined with their short validity period makes the authentication process robust against credential theft, replay attacks, and brute-force attempts."}, "implementation_complexity": {"score": 3, "rationale": "POTP adds significant implementation complexity because it requires infrastructure for generating, transmitting, and validating one-time passwords. Depending on the delivery method (e.g., SMS, email, or mobile app), additional third-party services or integrations may be required. Moreover, the system must handle OTP expiration, retries, and potential delivery issues, making it more complex to implement than static password systems."}, "infrastructure_dependency": {"score": 3, "rationale": "POTP increases infrastructure dependency because the system must generate, deliver, and validate one-time passwords. Depending on the delivery mechanism (e.g., SMS, email, or mobile apps), the system may need to integrate with external services or deploy additional infrastructure to support secure OTP generation and delivery. These requirements make it more dependent on reliable infrastructure than static password systems."}}', 1) ON CONFLICT (id) DO NOTHING;
INSERT INTO public.security_patterns (id, name, description, properties, security_control) VALUES (11, 'Hardware Token-Based Authentication', '{"intent": "Provide a secure method of authentication by requiring users to physically possess a hardware token, which contains cryptographic credentials necessary for secure login, thereby strengthening authentication against remote attacks like phishing and credential theft.", "problem": "How can a system authenticate a user in a straightforward, device-agnostic manner, ensuring that only authorized users can access it while maintaining a relatively low level of complexity?", "solution": "Hardware token-based authentication relies on a physical device, such as a USB security key, smart card, or other hardware tokens, that stores cryptographic credentials or keys. During the authentication process, the user connects or presents the token to their device, which uses the cryptographic credentials stored on the token to sign a challenge provided by the server. The server then verifies this signed challenge using the public key associated with the token. This approach ensures that authentication requires physical possession of the token and prevents unauthorized remote access.", "consequences": {"negative": [{"factor": "Device Dependency", "reason": "Users must have access to the hardware token, and losing it may prevent them from accessing the system."}, {"factor": "Cost and Management", "reason": "Requires issuing and managing hardware tokens, which may introduce additional costs and logistical challenges."}, {"factor": "User Experience", "reason": "Can be less convenient than password or software-based authentication methods, especially in environments where users must authenticate frequently or on multiple devices."}, {"factor": "Token Compatibility", "reason": "The system and devices must support the hardware token interface (e.g., USB, NFC), which may be limited in certain environments."}], "positive": [{"factor": "Strong Security", "reason": "Requires physical possession of the token, making remote attacks, such as phishing and credential theft, significantly more difficult."}, {"factor": "No Shared Secrets", "reason": "The cryptographic keys used in authentication are never shared over the network, reducing the risk of key exposure."}, {"factor": "Phishing Resistance", "reason": "Prevents attackers from using stolen credentials, as they would need the physical token to complete authentication."}]}, "participants": {"human": [{"name": "User", "description": "The individual who physically possesses the hardware token and connects it to their device during the authentication process."}], "non-human": [{"name": "Hardware Token", "description": "The device that securely stores the cryptographic credentials and performs cryptographic operations necessary for authentication."}, {"name": "Authentication System", "description": "Issues a challenge to the hardware token and verifies the signed response using the corresponding public key."}, {"name": "Device", "description": "Acts as the intermediary between the hardware token and the authentication system, relaying the challenge and signed response."}]}}', '{"cost": {"score": 2, "rationale": "The need to purchase and manage physical hardware tokens results in significant costs both for implementation and ongoing operations."}, "usability": {"score": 2, "rationale": "Lower usability because users must carry a physical token, which can be inconvenient. Losing or misplacing the token may cause access issues."}, "compliance": {"score": 5, "rationale": "Hardware tokens meet stringent compliance requirements, particularly in high-security environments such as finance and healthcare, due to their strong authentication mechanisms."}, "performance": {"score": 3, "rationale": "Performance is generally good, but communication between the token and the device introduces slight delays compared to other forms of authentication."}, "scalability": {"score": 2, "rationale": "Scalability is limited due to the need to physically distribute and manage tokens for all users, which becomes increasingly complex with large user bases."}, "auditability": {"score": 4, "rationale": "Hardware tokens provide strong auditability by tracking token usage and issuing secure authentication events, though managing the logs across devices adds complexity."}, "availability": {"score": 4, "rationale": "Availability is generally good, but users must have access to their hardware token to authenticate. Losing the token can prevent access temporarily."}, "confidentiality": {"score": 5, "rationale": "Confidentiality is high, as cryptographic credentials are securely stored on the hardware token, protecting them from unauthorized access."}, "mfa_suitability": {"score": 5, "rationale": "Physical possession makes it a strong and secure factor for MFA."}, "device_dependency": {"score": 5, "rationale": "Very high device dependency. Users must physically possess a hardware token (e.g., YubiKey or smart card) to authenticate. If the token is lost, access is lost until a replacement is issued."}, "security_strength": {"score": 5, "rationale": "Hardware token-based authentication provides strong security due to the reliance on physical possession of the token and cryptographic operations. It is highly resistant to remote attacks like phishing and credential theft."}, "recovery_complexity": {"score": 2, "rationale": "Losing a hardware token can prevent access until a replacement is issued, which can be time-consuming. Physical token management and re-issuance introduce operational overhead."}, "maintenance_complexity": {"score": 5, "rationale": "Maintenance complexity is high due to the need for managing tokens, handling replacements for lost tokens, and ensuring tokens remain secure over time."}, "resistance_to_phishing": {"score": 5, "rationale": "Highly resistant to phishing as the authentication process relies on something the user physically possesses, which attackers cannot steal remotely."}, "third_party_dependency": {"score": 1, "rationale": "No third-party dependency. Tokens are typically managed by the system and do not rely on external identity providers."}, "authentication_strength": {"score": 5, "rationale": "High authentication strength due to the requirement of physical possession of the token combined with secure cryptographic verification."}, "implementation_complexity": {"score": 4, "rationale": "Hardware token-based systems are complex to implement, as they require secure distribution, token management, and integration with authentication systems."}, "infrastructure_dependency": {"score": 3, "rationale": "Moderate infrastructure dependency for managing token issuance, revocation, and cryptographic challenge-response mechanisms. However, this is often less complex than biometric or passkey systems."}}', 1) ON CONFLICT (id) DO NOTHING;
INSERT INTO public.security_patterns (id, name, description, properties, security_control) VALUES (12, 'Certificate-Based Authentication', '{"intent": "Enable secure authentication by leveraging digital certificates issued by a trusted Certificate Authority (CA), ensuring identity verification through cryptographic means without the need for passwords.", "problem": "How can a system authenticate users securely, ensuring that their identity is verified by a trusted third party, while avoiding the vulnerabilities associated with password-based authentication?", "solution": "Certificate-based authentication uses public-key cryptography, where a user is issued a digital certificate by a trusted Certificate Authority (CA). The certificate contains the user''s public key and identifying information, and is signed by the CA. During authentication, the user presents their certificate to the system. The system verifies the certificate''s authenticity by checking the CA''s signature, and then uses the associated public key to establish the user''s identity. This method eliminates the need for passwords, providing a more secure authentication process. The private key, corresponding to the public key in the certificate, is stored securely on the user''s device.", "consequences": {"negative": [{"factor": "Certificate Management Overhead", "reason": "The system must manage issuing, renewing, and revoking certificates, which requires additional infrastructure and operational complexity."}, {"factor": "Private Key Protection", "reason": "The private key must be stored securely on the user’s device. If compromised, it can be difficult to recover or revoke access."}, {"factor": "CA Trust", "reason": "The security of the system is dependent on the trustworthiness and security practices of the Certificate Authority. If the CA is compromised, the entire system’s integrity could be undermined."}, {"factor": "Device Dependency", "reason": "Users need access to the device that holds the private key, meaning loss or theft of the device can cause accessibility and security challenges."}], "positive": [{"factor": "Strong Security", "reason": "Provides cryptographically secure authentication without relying on passwords, reducing vulnerability to phishing, brute-force attacks, and credential theft."}, {"factor": "Scalability", "reason": "Certificate-based authentication is scalable across large systems and networks, allowing centralized management of user credentials via a trusted CA."}, {"factor": "Non-Repudiation", "reason": "Digital certificates provide non-repudiation, meaning that a user cannot deny having performed an action or transaction if their private key was used."}]}, "participants": {"human": [{"name": "User", "description": "The individual who holds a digital certificate and securely stores the corresponding private key."}], "non-human": [{"name": "Authentication System", "description": "Verifies the digital certificate''s authenticity and the user''s identity by validating the CA''s signature and using the public key to establish the user''s identity."}, {"name": "Certificate Authority (CA)", "description": "A trusted third party that issues and signs digital certificates, verifying the identity of users."}, {"name": "Certificate Storage", "description": "The location where the user''s certificate and private key are stored, typically in a secure enclave or protected environment."}]}}', '{"cost": {"score": 2, "rationale": "The cost of implementing and maintaining PKI infrastructure is substantial, especially for large-scale deployments where certificates must be issued and managed securely."}, "usability": {"score": 2, "rationale": "Certificates are generally managed behind the scenes, but the complexity of private key management can create usability challenges, especially for users who are not familiar with PKI."}, "compliance": {"score": 5, "rationale": "Certificate-based authentication easily meets compliance standards, particularly in industries with stringent security requirements, such as finance, healthcare, and government."}, "performance": {"score": 3, "rationale": "Cryptographic operations involved in certificate-based authentication can introduce some performance overhead, especially in large-scale or high-traffic environments."}, "scalability": {"score": 4, "rationale": "Certificate-based authentication scales well in environments with established PKI infrastructure, though managing certificates at scale introduces operational complexity."}, "auditability": {"score": 5, "rationale": "Excellent auditability through the logging of certificate issuance, use, and revocation events, allowing for a clear audit trail in case of security incidents."}, "availability": {"score": 4, "rationale": "Strong availability if PKI is well-managed, but issues arise if certificates expire or if the PKI is compromised, which could cause service disruptions."}, "confidentiality": {"score": 5, "rationale": "Very strong confidentiality as private keys are securely stored and never transmitted over the network, ensuring data protection at all times."}, "mfa_suitability": {"score": 4, "rationale": "Strong cryptographic factor, suitable for MFA, but requires complex infrastructure."}, "device_dependency": {"score": 4, "rationale": "High device dependency. The user must possess a device (e.g., smart card or trusted device) that securely stores the private key required for authentication."}, "security_strength": {"score": 5, "rationale": "Certificate-based authentication provides extremely strong security using digital certificates and public-key infrastructure (PKI). It is resistant to man-in-the-middle and impersonation attacks."}, "recovery_complexity": {"score": 3, "rationale": "Re-issuing a digital certificate requires going through the Certificate Authority (CA), which can take time and effort. If private keys are compromised, certificates must be revoked, and new ones issued, which adds complexity."}, "maintenance_complexity": {"score": 5, "rationale": "Maintenance complexity is very high due to the need to manage certificate lifecycles, including renewal, revocation, and secure storage. Any issues in the PKI can lead to widespread security vulnerabilities."}, "resistance_to_phishing": {"score": 5, "rationale": "Strong resistance to phishing attacks due to the use of cryptographic certificates that cannot be easily forged or stolen by attackers."}, "third_party_dependency": {"score": 2, "rationale": "Some third-party dependency. The system relies on Certificate Authorities (CAs) to issue and verify certificates, though users don’t depend on external identity providers for day-to-day authentication."}, "authentication_strength": {"score": 5, "rationale": "Authentication strength is very high due to the use of cryptographic certificates that ensure both the identity of the user and the integrity of the authentication process."}, "implementation_complexity": {"score": 5, "rationale": "Implementation complexity is high due to the need for a full Public Key Infrastructure (PKI), including certificate issuance, management, and validation mechanisms."}, "infrastructure_dependency": {"score": 5, "rationale": "High infrastructure dependency. Managing digital certificates, CAs, and secure key storage requires complex infrastructure, including revocation systems and public-key infrastructure (PKI)."}}', 1) ON CONFLICT (id) DO NOTHING;
INSERT INTO public.security_patterns (id, name, description, properties, security_control) VALUES (13, 'OTP-Based Authentication', '{"intent": "Provide a secure, time-sensitive authentication method by generating a one-time password (OTP) that is valid for a single session or transaction, reducing the risks of credential theft and replay attacks.", "problem": "How can a system ensure that a user can authenticate securely without relying on static credentials that may be stolen, reused, or compromised?", "solution": "OTP-based authentication generates a unique password that is valid for a single session or transaction. The OTP is typically generated using a time-based or event-based algorithm, and delivered to the user via an out-of-band channel such as a mobile app (e.g., Google Authenticator), SMS, or email. The user enters the OTP in addition to or instead of a traditional password. The system verifies the OTP by calculating the expected value based on the same algorithm, ensuring that it is valid within a specific timeframe or event. OTPs mitigate the risks of credential theft, since the password is temporary and cannot be reused.", "consequences": {"negative": [{"factor": "Device Dependency", "reason": "OTP-based authentication often requires the user to have access to a device (e.g., mobile phone) to receive or generate the OTP, which can cause issues if the device is lost or unavailable."}, {"factor": "Vulnerabile Delivery Channels", "reason": "If the delivery channel (e.g., SMS) is compromised, an attacker could intercept the OTP, reducing the security benefits."}, {"factor": "Limited Usability", "reason": "Users may find it inconvenient to enter a new password for each session or transaction, particularly if the OTP delivery method is slow or unreliable."}, {"factor": "Implementation Complexity", "reason": "Requires infrastructure for securely generating and delivering OTPs, as well as managing shared secrets for time-based algorithms."}], "positive": [{"factor": "Enhanced Security", "reason": "OTPs are valid for only a short time or single transaction, reducing the risk of credential theft, phishing, and replay attacks."}, {"factor": "No Password Reuse", "reason": "Since the OTP changes with each login or transaction, there is no risk of password reuse, a common security flaw in traditional password-based systems."}, {"factor": "Cost-Effective", "reason": "Requires no additional infrastructure beyond secure password storage."}, {"factor": "Out-of-Band Delivery", "reason": "The use of a separate delivery channel (e.g., SMS, mobile app) for the OTP enhances security by creating an additional layer of defense."}]}, "participants": {"human": [{"name": "User", "description": "The individual who receives and enters the one-time password during authentication."}], "non-human": [{"name": "OTP Generator", "description": "The system or application that generates the OTP using a time-based or event-based algorithm."}, {"name": "Authentication System", "description": "Verifies the OTP provided by the user by recalculating the expected OTP based on the shared secret and current time or event."}, {"name": "Delivery Channel", "description": "The method by which the OTP is delivered to the user, such as SMS, email, or mobile application."}]}}', '{"cost": {"score": 3, "rationale": "Software-based OTP systems have low costs, while hardware-based OTP systems are more expensive due to the need to manage physical tokens. Overall, it is more affordable than biometric or hardware-token-based systems but can become expensive with hardware tokens."}, "usability": {"score": 3, "rationale": "OTP-based systems are moderately usable but introduce friction, as users need to receive and enter OTPs. Delays or issues in delivery (e.g., SMS) can hinder user experience."}, "compliance": {"score": 4, "rationale": "OTPs meet compliance requirements in many industries, but some regulatory frameworks may require additional factors for high-security environments."}, "performance": {"score": 3, "rationale": "OTP generation and server-side verification are quick, but the overall performance can be impacted by the time-sensitive delivery of OTPs, particularly if relying on external services like SMS or email."}, "scalability": {"score": 3, "rationale": "Scales moderately well but requires infrastructure for generating and delivering OTPs, which can become a bottleneck with large-scale implementations."}, "auditability": {"score": 3, "rationale": "OTPs provide moderate auditability, but they are typically short-lived, limiting the depth of information available for auditing purposes."}, "availability": {"score": 3, "rationale": "Availability is dependent on the delivery mechanism. Issues with SMS or email infrastructure can cause delays, making OTP-based systems less reliable in some cases."}, "confidentiality": {"score": 3, "rationale": "Confidentiality is maintained by the short lifespan of OTPs, but delivery mechanisms such as SMS or email may be vulnerable to interception."}, "mfa_suitability": {"score": 5, "rationale": "Dynamic, time-sensitive, and widely adopted as a second factor in MFA setups."}, "device_dependency": {"score": 3, "rationale": "Moderate device dependency. OTP-based authentication requires access to a secondary device (e.g., smartphone) to receive the OTP via SMS, email, or an authenticator app. Device loss is manageable but impacts access."}, "security_strength": {"score": 4, "rationale": "OTP-based authentication provides strong security as one-time passwords are short-lived and only valid for a single session, reducing the risk of credential theft."}, "recovery_complexity": {"score": 4, "rationale": "OTP-based systems are easier to recover since they often involve receiving new OTPs through mobile devices or email. However, if the user loses access to their delivery method (e.g., phone or email), recovery may become more difficult."}, "maintenance_complexity": {"score": 3, "rationale": "Maintenance complexity is moderate, as OTP systems require secure management of shared secrets, synchronization, and ensuring the reliability of delivery channels."}, "resistance_to_phishing": {"score": 3, "rationale": "OTPs reduce phishing risks but are still vulnerable if attackers intercept or steal the OTP during its short validity period."}, "third_party_dependency": {"score": 3, "rationale": "Moderate third-party dependency, especially when SMS or email is used to send OTPs. Systems rely on external communication providers for OTP delivery."}, "authentication_strength": {"score": 3, "rationale": "OTP authentication is strong, but vulnerable if the delivery mechanism (e.g., SMS or email) is compromised. Time-sensitive OTPs limit their reuse."}, "implementation_complexity": {"score": 3, "rationale": "Moderate complexity as OTP systems require generating, delivering, and verifying time-sensitive OTPs while ensuring the security of the delivery channel."}, "infrastructure_dependency": {"score": 2, "rationale": "Low infrastructure dependency. OTPs require an algorithm (TOTP/HOTP) for generation and validation, but no complex cryptographic infrastructure is needed. SMS/email delivery introduces third-party dependence."}}', 1) ON CONFLICT (id) DO NOTHING;
INSERT INTO public.security_patterns (id, name, description, properties, security_control) VALUES (14, 'Token-Based Authentication', '{"intent": "Provide a secure method of authentication by using cryptographic tokens instead of traditional credentials, reducing the risks of credential theft and replay attacks.", "problem": "How can a system authenticate users without relying on reusable credentials like passwords, while ensuring security against credential theft and replay attacks?", "solution": "Token-based authentication relies on cryptographic tokens, which are issued to the user after initial authentication and used for subsequent session-based or stateless authentication. These tokens can be session-based (tied to a specific session) or stateless (e.g., JSON Web Tokens, or JWTs). When a user successfully authenticates (via a password, OAuth, etc.), the system issues a token. For each subsequent request, the token is passed to the server, which verifies it and grants access. Tokens often have a set expiration time to minimize security risks. They are typically signed and can be validated without needing to store them on the server, ensuring the integrity of the authentication process.", "consequences": {"negative": [{"factor": "Token Theft", "reason": "If a token is stolen, the attacker may use it to gain unauthorized access until the token expires or is revoked."}, {"factor": "Expiration Management", "reason": "Tokens must have an expiration mechanism in place to limit their lifetime, adding complexity to session management."}, {"factor": "Security Complexity", "reason": "Implementing token-based systems requires secure key management (for signing tokens) and secure storage of tokens on client devices to prevent theft."}, {"factor": "Replay Attacks", "reason": "While tokens minimize credential reuse, they are still susceptible to replay attacks if stolen and not properly protected."}], "positive": [{"factor": "Reduced Credential Exposure", "reason": "Tokens reduce the need to repeatedly send credentials (like passwords) with each request, lowering the attack surface for credential theft."}, {"factor": "Stateless Authentication", "reason": "Tokens (e.g., JWTs) can be stateless, which simplifies scalability because the server doesn’t need to store session information."}, {"factor": "Flexibility", "reason": "Token-based authentication can be used across different platforms and systems, making it suitable for distributed environments like microservices and APIs."}, {"factor": "Revocability", "reason": "Tokens can be revoked when necessary, offering control over session management."}]}, "participants": {"human": [{"name": "User", "description": "The individual who receives a token after successful authentication and uses it to authenticate further requests."}], "non-human": [{"name": "Authentication System", "description": "Issues a token upon successful authentication and verifies the token in subsequent requests."}, {"name": "Token Provider", "description": "The entity responsible for generating, signing, and issuing tokens, such as an OAuth provider."}, {"name": "Token Consumer", "description": "The system or service that verifies the token before granting access to resources."}]}}', '{"cost": {"score": 4, "rationale": "Token-based authentication is relatively inexpensive to implement and maintain, with minimal infrastructure requirements. The main costs come from ensuring token security (e.g., signing and verifying tokens) but are lower than those for biometric or hardware-token-based methods."}, "usability": {"score": 4, "rationale": "Token-based authentication is user-friendly if tokens are handled transparently (e.g., automatic refreshes in OAuth flows), minimizing the need for user intervention."}, "compliance": {"score": 4, "rationale": "Token-based systems can meet compliance requirements, especially in distributed environments. However, additional factors may be needed to meet high-security standards like MFA."}, "performance": {"score": 5, "rationale": "Token-based authentication is highly performant, especially with stateless tokens, as the server doesn’t need to maintain session state. Token signing and verification are lightweight operations."}, "scalability": {"score": 5, "rationale": "Token-based systems, especially stateless ones, scale extremely well in distributed environments like microservices, as tokens can be validated without session management."}, "auditability": {"score": 4, "rationale": "Token-based systems allow detailed auditing, particularly when tokens carry claims (e.g., user roles, timestamps). However, managing and tracking token usage can add complexity."}, "availability": {"score": 5, "rationale": "Stateless tokens (e.g., JWT) provide high availability since they can be validated independently of the issuing server, making the system resilient to downtime or failures."}, "confidentiality": {"score": 4, "rationale": "Confidentiality is strong when tokens are signed and encrypted, reducing the likelihood of data exposure. However, storing tokens insecurely can compromise confidentiality."}, "mfa_suitability": {"score": 3, "rationale": "Provides a strong session management factor, but typically used after primary authentication."}, "device_dependency": {"score": 2, "rationale": "Low to moderate device dependency, depending on whether the token is stored in a browser session or on a user device. Stateless tokens (e.g., JWTs) reduce device dependence, while session-based tokens may require device management."}, "security_strength": {"score": 4, "rationale": "Token-based authentication is strong when tokens are cryptographically signed and secured. However, token theft or replay attacks can still pose a threat if tokens are not properly protected."}, "recovery_complexity": {"score": 3, "rationale": "Recovery is moderate since tokens are often short-lived and can be revoked. Users can generate new tokens by re-authenticating via a primary method like a password or OTP, but token theft can introduce complications."}, "maintenance_complexity": {"score": 3, "rationale": "Token expiration and revocation need to be managed securely. Stateless tokens simplify session maintenance but add complexity in terms of secure key management and token handling."}, "resistance_to_phishing": {"score": 4, "rationale": "Tokens are resistant to phishing as long as they are managed securely. However, if tokens are exposed (e.g., in local storage or through insecure channels), phishing remains a concern."}, "third_party_dependency": {"score": 1, "rationale": "Minimal third-party dependency. The system itself typically generates and validates tokens without relying on external providers."}, "authentication_strength": {"score": 4, "rationale": "Authentication strength is strong, especially with stateless tokens like JWT, which are cryptographically signed. However, stolen tokens can still be used until they expire or are revoked."}, "implementation_complexity": {"score": 3, "rationale": "Implementing token-based systems requires secure token issuance, signing, validation, and revocation, adding moderate complexity to the system."}, "infrastructure_dependency": {"score": 4, "rationale": "High infrastructure dependency. Token-based authentication (especially with stateless tokens) requires secure handling of tokens, signing keys, and revocation mechanisms. Complex key management is often needed."}}', 1) ON CONFLICT (id) DO NOTHING;

INSERT INTO public.preference_elicitation_dialogs (id, content, security_control_id, security_pattern_id) VALUES (1, '{"authBudget": {"answers": [{"answerKey": "LOW", "displayText": "Low Budget", "nextQuestion": "deviceDependency"}, {"answerKey": "MEDIUM", "displayText": "Medium Budget", "nextQuestion": "deviceDependency"}, {"answerKey": "HIGH", "displayText": "High Budget", "nextQuestion": "deviceDependency"}], "displayText": "What budget is available for implementing authentication in your system?"}, "entryPoint": "securityUsabilityTradeoff", "requireMFA": {"answers": [{"answerKey": "YES", "displayText": "Yes, MFA will be required", "nextQuestion": "authBudget"}, {"answerKey": "NO", "displayText": "No, MFA will not be required", "nextQuestion": "authBudget"}], "displayText": "Will Multi-Factor Authentication (MFA) be required for your system?"}, "deviceDependency": {"answers": [{"answerKey": "SHARED_DEVICE", "displayText": "Yes, devices are shared among users", "nextQuestion": "end"}, {"answerKey": "PERSONAL_DEVICE", "displayText": "No, each user has their own device", "nextQuestion": "end"}], "displayText": "Will authentication need to accommodate shared devices, where multiple users authenticate on the same device?"}, "securityUsabilityTradeoff": {"answers": [{"answerKey": "USABILITY", "condition": {"dependsOn": "authenticationExperience", "notAllowedAnswers": ["MFA"]}, "displayText": "Ease of Use", "nextQuestion": "requireMFA"}, {"answerKey": "MODERATE", "displayText": "Balanced", "nextQuestion": "requireMFA"}, {"answerKey": "SECURITY", "displayText": "Security Focus", "nextQuestion": "requireMFA"}], "displayText": "Authentication methods often involve a tradeoff between usability and security. How would you prioritize this tradeoff for your system?"}}', 1, null) ON CONFLICT (id) DO NOTHING;


INSERT INTO public.constraints (id, name, description, applicability_expression, satisfaction_expression, satisfied_explanation_expression, violated_explanation_expression, weight, is_hard, created_at, updated_at, security_control_id, security_pattern_id) VALUES (2, 'Minimum Scalability for Large User Bases', 'Ensures that the security pattern provides adequate scalability to accommodate the demands of a large user base, maintaining performance and reliability under high load conditions.', 'project.properties[''userBaseSize''] == ''LARGE''', 'securityPattern.properties[''scalability''][''score''] >= 4', 'securityPattern.name + '' meets the minimum scalability requirement for a large user base (4), with an assessed scalability of: '' + securityPattern.properties[''scalability''][''score'']', '''''', 1, true, null, null, 1, null) ON CONFLICT (id) DO NOTHING;
INSERT INTO public.constraints (id, name, description, applicability_expression, satisfaction_expression, satisfied_explanation_expression, violated_explanation_expression, weight, is_hard, created_at, updated_at, security_control_id, security_pattern_id) VALUES (1, 'Minimum Security Strength for Financial Data', 'Ensures that the security pattern provides sufficient security strength when the application handles financial data, thereby protecting sensitive information and meeting high-security requirements specific to financial systems.', 'project.properties[''typeOfData''].contains(''FINANCIAL'')', 'securityPattern.properties[''security_strength''][''score''] >= 4', 'securityPattern.name + '' meets the minimum security strength requirement of 4, with an assessed security strength of: '' + securityPattern.properties[''security_strength''][''score'']', '''''', 1, true, '2025-01-08 23:52:34.476000 +00:00', '2025-01-08 23:52:37.034000 +00:00', 1, null) ON CONFLICT (id) DO NOTHING;
INSERT INTO public.constraints (id, name, description, applicability_expression, satisfaction_expression, satisfied_explanation_expression, violated_explanation_expression, weight, is_hard, created_at, updated_at, security_control_id, security_pattern_id) VALUES (3, 'Usability Preference', 'Ensures that security patterns enhancing usability are ranked higher when the tradeoff between security and usability prioritizes usability.', 'userPreferences[''securityUsabilityTradeoff''] == ''USABILITY''', 'securityPattern.properties[''usability''][''score''] >= 4', 'securityPattern.name + '' is highly regarded for its usability, with an assessed score of: '' + securityPattern.properties[''usability''][''score'']', 'securityPattern.name + '' only has an assessed usability of: '' + securityPattern.properties[''usability''][''score'']', 1, false, null, null, 1, null) ON CONFLICT (id) DO NOTHING;

